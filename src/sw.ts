/// <reference lib="webworker" />

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies'
import { ExpirationPlugin } from 'workbox-expiration'
import { BackgroundSyncPlugin } from 'workbox-background-sync'
import { Queue } from 'workbox-background-sync'

declare const self: ServiceWorkerGlobalScope

// Precache all the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST)

// Clean up any previous workbox caches
cleanupOutdatedCaches()

// Cache strategy for API calls
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/') || url.hostname.includes('supabase'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 5 * 60, // 5 minutes
        purgeOnQuotaError: true,
      }),
    ],
  })
)

// Cache strategy for static assets (images, fonts, etc.)
registerRoute(
  ({ request }) => 
    request.destination === 'image' ||
    request.destination === 'font' ||
    request.destination === 'style',
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true,
      }),
    ],
  })
)

// Cache strategy for JavaScript and CSS files
registerRoute(
  ({ request }) => 
    request.destination === 'script' ||
    request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'js-css-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
        purgeOnQuotaError: true,
      }),
    ],
  })
)

// Background sync for offline form submissions
const bgSyncPlugin = new BackgroundSyncPlugin('offline-submissions', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 hours (in minutes)
})

// Register background sync route for form submissions
registerRoute(
  ({ url, request }) => 
    url.pathname.includes('/api/visits') && request.method === 'POST',
  new NetworkFirst({
    cacheName: 'submissions-cache',
    plugins: [bgSyncPlugin],
  })
)

// Create a queue for offline visit submissions
const visitQueue = new Queue('visit-submissions', {
  onSync: async ({ queue }) => {
    let entry
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request)
        console.log('Offline visit submission successful:', entry.request.url)
      } catch (error) {
        console.error('Failed to submit offline visit:', error)
        // Re-add to queue for retry
        await queue.unshiftRequest(entry)
        throw error
      }
    }
  },
})

// Handle offline visit submissions
self.addEventListener('fetch', (event) => {
  if (
    event.request.url.includes('/api/visits') && 
    event.request.method === 'POST'
  ) {
    event.respondWith(
      fetch(event.request).catch(() => {
        // Add to background sync queue if offline
        return visitQueue.pushRequest({ request: event.request })
      })
    )
  }
})

// Cache dashboard data with short TTL for real-time updates
registerRoute(
  ({ url }) => 
    url.pathname.includes('/dashboard') || 
    url.pathname.includes('/analytics'),
  new StaleWhileRevalidate({
    cacheName: 'dashboard-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 2 * 60, // 2 minutes for real-time feel
        purgeOnQuotaError: true,
      }),
    ],
  })
)

// Handle navigation requests (SPA routing)
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new StaleWhileRevalidate({
    cacheName: 'navigation-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
        purgeOnQuotaError: true,
      }),
    ],
  })
)

// Custom caching for Recharts and chart data
registerRoute(
  ({ url }) => url.pathname.includes('recharts') || url.pathname.includes('chart'),
  new CacheFirst({
    cacheName: 'charts-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 1 week
        purgeOnQuotaError: true,
      }),
    ],
  })
)

// Handle push notifications for real-time updates
self.addEventListener('push', (event) => {
  if (event.data) {
    const data = event.data.json()
    const options = {
      body: data.body,
      icon: '/favicon.ico',
      badge: '/favicon.ico',
      data: data.data,
      actions: [
        {
          action: 'view',
          title: 'View Details'
        },
        {
          action: 'dismiss',
          title: 'Dismiss'
        }
      ]
    }

    event.waitUntil(
      self.registration.showNotification(data.title, options)
    )
  }
})

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close()

  if (event.action === 'view') {
    // Open the app to the relevant page
    event.waitUntil(
      self.clients.openWindow(event.notification.data?.url || '/')
    )
  }
})

// Handle sync events for background sync
self.addEventListener('sync', (event) => {
  if (event.tag === 'visit-submissions') {
    event.waitUntil(visitQueue.replayRequests())
  }
})

// Performance monitoring
self.addEventListener('fetch', (event) => {
  const startTime = performance.now()
  
  event.respondWith(
    caches.match(event.request).then((response) => {
      const duration = performance.now() - startTime
      
      // Log slow cache lookups in development
      if (duration > 100 && process.env.NODE_ENV === 'development') {
        console.warn(`Slow cache lookup: ${event.request.url} took ${duration}ms`)
      }
      
      return response || fetch(event.request)
    })
  )
})

// Skip waiting and claim clients immediately for updates
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
})

// Claim all clients immediately after activation
self.addEventListener('activate', (event) => {
  event.waitUntil(self.clients.claim())
})

// Handle app updates
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'APP_UPDATE_AVAILABLE') {
    // Notify clients about available update
    self.clients.matchAll().then((clients) => {
      clients.forEach((client) => {
        client.postMessage({
          type: 'UPDATE_AVAILABLE',
          payload: 'A new version of the app is available!'
        })
      })
    })
  }
})